# 列表(List)
- 列表是一个队列，一个排列整齐的队伍
- 列表内的个体称之为元素，由若干个元素组成列表
- 元素可以是任意的对象(数字、字符串、对象、列表)
- 列表内元素是有顺序的，可以使用索引
- 线性的数据结构
- 使用 `[]`表示
- 列表是可变的


## 内存的线性编制
| 内存空间1 | 内存空间2 | 内存空间3 | 内存空间4 | 内存空间5 | 内存空间6 | 内存空间7 |
| --------- | --------- | --------- | --------- | --------- | --------- | --------- |
| 1         | 2         | 3         | 4         | 5         |     空余      |     空余      |   

- 可以看出来，列表在内存中是这样存储的
- 其实Python列表就是C语言的数组包装出来的

>由于这种有顺序的数据，删除其中某个数值，例如删除[0,1,2,3,4,5,6,7]的元素`0`，那列表中的除了0以外的元素将全部移动一位，这会大大影响效率！  
所以列表的增删对列表的末尾操作影响效率小，同时列表对元素的定位效率很快


## 列表初始化
- list()函数可以构建列表，也可以直接定义列表
- 列表的元素可以是各种类型

```python
l1 = []
l2 = list()
l3 = list(range(5))
print(l1,l2,l3)
    [] [] [0, 1, 2, 3, 4]
```


## 列表索引
- 列表中的每个元素都有一个索引，从0开始计数
- 列表的最大索引值为其长度减一
- 列表支持负索引，从-1开始
- 索引不可超界，否则会抛异常


```python
>>> a = list(range(1,10)) #定义一个列表
>>> a
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a[0] #a的第一个元素
1
>>> a[1]
2
>>> a[-1] #a的最后一个元素
9
>>> a[9] a的第10个元素，可以看到会报错，超出索引
Traceback (most recent call last):
  File "<pyshell#139>", line 1, in <module>
    a[9]
IndexError: list index out of range
>>> a[8] 访问a的第九个元素
9
```


## 列表属性
### 查看元素的索引

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a.index(4)
3
>>> a.index(9)
8
>>> a.index(99)
Traceback (most recent call last):
  File "<pyshell#145>", line 1, in <module>
    a.index(99)
ValueError: 99 is not in list #没有值也会报错
```

### count
查看列表中元素出现的次数

```python
>>> a = [1,2,1,3,1,41,5,1,2]
>>> a.count(1)
4
>>> a.count(2)
2
>>> a.count(100)
0
```

> count函数使用时会将列表的元素从头至尾全部访问一遍。效率较低
- v假设有n个元素，其时间复杂度为O(n)
- 举个例子，无论列表有多少元素，查询索引为6的元素的值，其时间复杂度为O(1)
- 问题来了，index(函数)的时间复杂度呢？我们一般假设最糟糕的情况就是从头到尾的查询一般，所以其时间复杂度为O(n)
- 所以，index()和count()这种时间复杂度为O(n),少用！

### len()
len()为内建函数，返回一个对象的长度

```
>>> a = [1,2,3,4,5]
>>> len(a)
5
```

>list列表有一个内置属性，每增加一个或减少一个，其计数器会改变;所以len()的时间复杂度不是O(n),而是O(1)!



## 列表增加、插入元素

### append()
在列表的尾部追加元素
返回值是None

```python
>>> a = [1,2,3]
>>> a.append(1)
>>> a
[1, 2, 3, 1]
>>> a.append(4)
>>> a
[1, 2, 3, 1, 4]

```

### insert()
在指定位置插入元素
- 超过上界，左边插入
- 超过下界，右边插入
- 返回值是None

```python
[1, 2, 3, 1, 4]    
>>> a.insert(0,33)   #在索引为0的位置增加33这个元素
>>> a
[33, 1, 2, 3, 1, 4]

```

>在指定位置插入指定元素，虽然定位位置很快，但是插入元素之后，还是要移动之后的所有元素，所以时间复杂度为O(n)
空间占用越大，空间复杂度越高

## extend
扩展列表
- append()一次只能加一堆元素
- extend能扩展可迭代对象和多个元素

```python
>>> b = [4,5,6]
>>> a = [1,2,3]
>>>c =  a.extend(b)
>>> c
[1, 2, 3, 4, 5, 6]
```


## 列表的乘法
注意，会得到一个新列表等
```python
>>> a = [1,2,3]
>>> a*2
[1, 2, 3, 1, 2, 3]
```
