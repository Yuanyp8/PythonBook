# Python内存管理
- Python是一门动态语言，运行于python虚拟机之上，与Java类似，所有的变量不需要清除，有自己的垃圾回收机制，不像C或者C++需要手动回收垃圾
- python不需要关心变量的存亡，也不需要关心内存管理
- 使用计数器记录所有对象的引用次数

## 内存管理

1. 假设一个内存空间被分为5部分

| 空间1 | 空间2 | 空间3 | 空间4 | 空间5 |
| ----- | ----- | ----- | ----- | ----- |
|   占用    |       |  占用     |   占用    |       |

2. 现在，空间1和空间5被空闲出来

| 空间1 | 空间2 | 空间3 | 空间4 | 空间5 |
| ----- | ----- | ----- | ----- | ----- |
|       |       |  占用     |      |       |

3. 此时，如果有一批服务被启动，需要四块内存空间；并且，需要的是四块连续的内存空间！这时候，虽然内容空间富裕，但是是碎片化的内存空间，也是不可利用的，这个服务就不能被启动

| 空间1 | 空间2 | 空间3 | 空间4 | 空间5 |
| ----- | ----- | ----- | ----- | ----- |
|    碎片   |   碎片      |  占用     |    碎片    |     碎片    |

4. 对于Python来说，Python不需要考虑这种内存碎片管理，类似于Java的多代和分代；它会自主清理整合碎片内存空间，形成如下格局，这样就会有连续的内存空间可以使用

| 空间1 | 空间2 | 空间3 | 空间4 | 空间5 |
| ----- | ----- | ----- | ----- | ----- |
|       |       |       |      |   占用    |



## 计数器
### GC
 当引用计数为0时，就可以被垃圾回收GC
### 计数模式

#### 计数增加
- 赋值给其他变量就会增加引用计数，例如`x=3;y=x;z=[x,1]`
- 实参传参，如`foo(y)`

#### 计数减少
- 函数运行结束时，局部变量就会被自动销毁，对象的引用计数减少
- 变量被赋值给其他对象，例如`x=3;y=x;x=4`

### 实践
注意，不要用常量或ipython来试，例如常量1不只被你引用，内存中的1指向的都是一个常量。
#### 引用计数增加

```
import sys      # 导入python自带的sys库
x = []          # 将 x 赋值为一个空列表
print(sys.getrefcount(x))       #打印变量x 的引用计数
----
  2
```
>为什么结果会是2，因为前面赋值是引用一次，后面的打印里面是实参传入，引用计数会加一次，所以引用计数是2

```
x = []  # 1
y = x   # 2
z = x   # 3
print(sys.getrefcount)  # 4
----
4


x = []  # 1
y = x   # 2
z = x   # 3
q = z   # 4
print(sys.getrefcount(x))  # 5
----
5
```

#### 引用计数减少

```
import sys
x = []  # 1
y = x   # 2
z = y   # 3
print(sys.getrefcount(x))  # 4


x = 1    # 引用计数减少
print(sys.getrefcount(z))    # 此时z的引用计数应该为4-1

y = 2
print(sys.getrefcount(z))    # 此时z的引用计数应该为4-1-1

----
4
3
2

```

>当引用计数为0时，GC不会立刻启动，它会在合适的时间去启动GC，也不用手动去清除垃圾，这种虚拟机上的语言，如Java或Python都是这种机制


## 性能
有关性能的时候，就需要考虑变量的引用问题，但是释放内存还是尽量不释放内存，看需求！
